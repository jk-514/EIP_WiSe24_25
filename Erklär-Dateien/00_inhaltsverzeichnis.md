# Inhaltsverzeichnis

## Datentypen und Operationen

> [Link](01_datentypen_operationen.md)

- `int` (Ganzzahlen)
- `float` (Gleitkommazahlen)
- `bool` (Boolesche Werte)
- `str` (Strings)
- `None`
- Nutzereingaben
- Variablen benennen


## Kontrollstrukturen

> [Link](02_kontrollstrukturen.md)

- `if`-Statements
- `while`-Schleifen
- for-Schleifen
- Steueranweisungen: `break`, `continue` und `pass`


## Die Module math, random und string

> [Link](03_math_random_string_module.md)

- Einführung in das `math`-Modul
- Einführung in das `random`-Modul
- Einführung in das `string`-Modul


## Listen

> [Link](04_listen.md)

- Einführung
- Operationen mit Listen
- Mit `for`-Schleifen über Listen iterieren
- Unterschied zwischen mutablen und nicht-mutablen Datentypen
- `copy()` und `deepcopy()`
- Slicing


## Zweidimensionale Listen

> [Link](05_2d_listen.md)

- Erstellung von zweidimensionalen Listen
- Zugriff auf Elemente in zweidimensionalen Listen
- Negativer Index
- Iteration über zweidimensionale Listen
- Modifizieren von Elementen in einer zweidimensionalen Liste
- Slicing in zweidimensionalen Listen


## List Comprehension

> [Link](06_list_comprehension.md)

- Herleitung
- Einige Beispiele


## Dateien in Python einlesen und schreiben

> [Link](07_dateien.md)

- Das `open()`-Statement
- Modi zum Öffnen einer Datei
- Mit `with open()` Dateien öffnen
- Methoden zum Lesen einer Datei
- Iterieren über eine Datei
- Schreiben in eine Datei
- Datei schließen


## Arbeiten mit dem `os`-Modul

> [Link](08_os_modul.md)

- Aktuelles Arbeitsverzeichnis ermitteln
- Arbeitsverzeichnis ändern
- Inhalte eines Verzeichnisses auflisten
- Überprüfen, ob eine Datei existiert
- Existenz eines Pfades prüfen
- Verzeichnis erstellen
- Verzeichnis löschen
- Datei oder Verzeichnis umbenennen
- Dateien löschen
- Zusammenfassung


## Funktionen

> [Link](09_funktionen.md)

- `return`
- Parameterliste
- Call by Reference
- Standardwerte für Parameter
- Lambda-Funktionen
- `*args` und `**kwargs`


## Nützliche eingebaute Funktionen

> [Link](10_nuetzliche_funktionen.md)

- `sum()`
- `max()`
- `min()`
- `zip()`
- `enumerate()`
- `filter()`
- `map()`
- `sorted()`
- `any()`
- `all()`


## Rekursion

> [Link](11_rekursion.md)

- Aufbau einer rekursiven Funktion
- Beispiel: Fakultät berechnen
- Beispiel: Fibonacci-Zahlen
- Vorteile und Nachteile der Rekursion


## Backtracking

> [Link](12_backtracking.md)

- Aufbau eines Backtracking-Algorithmus
- Beispiel: Das N-Damen-Problem
- Zusammenfassung


## Tupel, Dictionaries und Sets

> [Link](13_tupel_dictionaries_sets.md)

- Tupel
- Dictionaries
- Sets
- Unterschiede zwischen Tupel, Dictionary und Set


## Dynamische Programmierung

> [Link](14_dynamische_programmierung.md)

- Beispiel: Fibonacci
- Ein weiterer Anwendungsfall


## Breitensuche (Breadth-First Search, BFS)

> [Link](15_breitensuche.md)

- Algorithmus
- Code


## Objektorientierte Programmierung (OOP)

> [Link](16_oop.md)

- Grundlagen der OOP
- Die Rolle von `self` in Python-Klassen
- Magische Methoden (Dunder-Methods)
- Getter und Setter
- Call by Reference


## Vererbung

> [Link](17_vererbung.md)

- Was ist Vererbung?
- Einfaches Beispiel:
- Der `super()`-Befehl
- Überschreiben von Methoden
- Die `isinstance()`-Funktion
- Die `issubclass()`-Funktion


## Fortgeschrittene OOP

> [Link](18_fortgeschrittene_oop.md)

- @staticmethod
- @classmethod
- Abstrakte Klassen (ABC) und @abstractmethod
- Abstrakte Klassen
- @abstractmethod


## Exceptions

> [Link](19_exceptions.md)

- Was sind Exceptions?
- Catching Exceptions
- Eigene Exceptions erstellen


## Eine Einführung zu Typehints

> [Link](20_typehints.md)

- Einführung
- Typehints für primitive Datentypen
- Typehints für Listen
- Typehints für Funktionen
- Typehints für Tupel
- Typehints für Sets
- Typehints für Dictionaries
- Probleme mit Typehints
- Wann Typehints verwenden?
